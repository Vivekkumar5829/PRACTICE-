
        // 1. Given sorted array, find the number of pairs which has a sum or difference is equal to k.
        public static int sumpairs(int[] arr, int k) {
            int start = 0;
            int end = arr.length - 1;
            int ans = 0;
            while (start < end) {
                if (arr[start] + arr[end] > k) {
                    end--;
                } else if (arr[start] + arr[end] < k) {
                    start++;
                } else {
                    if(arr[start] == arr[end]){
                        int n = (end - start);
                        ans += (n *(n+1)/2);
                        return ans;
                    }

                    if (arr[start] != arr[end]) {
                        int c1 = 0;
                        int c2 = 0;
                        int left = arr[start];
                        int right = arr[end];
                        while (left == arr[start]) {
                            c1++;
                            start++;
                        }
                        while (right == arr[end]) {
                            c2++;
                            end--;
                        }
                        ans += (c1 * c2);
                    }
                }

            }
            return ans;
        }

  // 2. 2824. Count Pairs Whose Sum is Less than Target.

    public static int countPairs(List<Integer> nums, int target) {
        int start = 0;
        int end = nums.size() - 1;
        int count = 0;
        Collections.sort(nums);

        while (start < end){
            if(nums.get(start) + nums.get(end) < target){
                count += end - start;
                start++;
            } else {
                end--;
            }
        }
        return count;
    }


   // 3. 2367. Number of Arithmetic Triplets.
    public int arithmeticTriplets(int[] nums, int diff) {
        Set<Integer> hst = new HashSet();
        for(int num: nums)
            hst.add(num);


        int i=0,j=1;
        int count=0;
        while(i<=j && j<nums.length){

            if(nums[j]-nums[i] < diff)
                j++;
            else if(nums[j]-nums[i]>diff)
                i++;
            else{
                if(hst.contains(nums[j]+diff)){
                    count++;
                }
                i++;
                j++;
            }
        }

        return count;
    }


// 4. 2697. Lexicographically Smallest Palindrome.
    public static String makeSmallestPalindrome(String s) {
        char[] ch = s.toCharArray();
        int start = 0;
        int end = s.length() - 1;

        while (start < end){
            if(ch[start] == ch[end]){
                start++;
                end--;
            }else {
                char minimum = (char)Math.min(ch[start],ch[end]);
                ch[start] = ch[end] = minimum;
                start++;
                end--;
            }
        }
        return new String(ch);
    }


// 5. 2108. Find First Palindromic String in the Array.
    public static String firstPalindrome(String[] words) {
        for (String word : words) {
            if (isPalindrome(word)) {
                return word;
            }
        }
        return "";
    }
    private static boolean isPalindrome(String word) {
        int start = 0;
        int end = word.length() - 1;
        while (start < end) {
            if (word.charAt(start) != word.charAt(end)) {
                return false;
            }
            start++;
            end--;
        }
        return true;
    }


    // 6.  1332. Remove Palindromic Subsequences.
    public static int removePalindromeSub(String s) {
        if (s.isEmpty()){
            return 0;
        } else if (isPalindrome1(s)) {
            return 1;
        }
        return 2;
    }

    private static boolean isPalindrome1(String word) {
        int start = 0;
        int end = word.length() - 1;
        while (start < end) {
            if (word.charAt(start) != word.charAt(end)) {
                return false;
            }
            start++;
            end--;
        }
        return true;
    }
